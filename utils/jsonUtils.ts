import { HistoryItem } from '../types';
import { parseVCardString } from './vcardUtils';
import { blobToBase64 } from './imageUtils';
import { addHistoryItem } from './db';

export const generateJSON = async (history: HistoryItem[], excludeImages: boolean = false): Promise<string> => {
    const contacts = await Promise.all(history.map(async (item) => {
        const parsed = parseVCardString(item.vcard);

        // Convert images to Base64 for export (only if not excluded)
        let imagesBase64: string[] = [];
        let imageRefs: string[] = [];

        if (item.images && item.images.length > 0) {
            if (excludeImages) {
                // Just generate refs, don't convert to base64
                imageRefs = item.images.map((_, index) => {
                    const suffix = index === 0 ? 'front' : index === 1 ? 'back' : `img${index + 1}`;
                    // Assume jpg for now, zipUtils will handle the actual file extension matching
                    return `${item.id}_${suffix}.jpg`;
                });
            } else {
                imagesBase64 = await Promise.all(item.images.map(async (img: any) => {
                    if (img instanceof Blob) {
                        return await blobToBase64(img);
                    }
                    if (typeof img === 'string' && img.startsWith('blob:')) {
                        try {
                            const res = await fetch(img);
                            const blob = await res.blob();
                            return await blobToBase64(blob);
                        } catch (e) {
                            console.error("Failed to fetch blob for export", e);
                            return null;
                        }
                    }
                    return img; // Already base64 or unknown
                }));
            }
        }

        return {
            id: item.id,
            name: item.name,
            organization: item.org,
            vcardData: parsed.data,
            rawVCard: item.vcard,
            images: excludeImages ? [] : imagesBase64.filter(i => i), // Filter nulls
            imageRefs: excludeImages ? imageRefs : undefined,
            source: item.images && item.images.length > 0 ? 'scan' : 'manual',
            timestamp: item.timestamp,
            createdAt: new Date(item.timestamp).toISOString()
        };
    }));

    const exportData = {
        version: "1.1", // Bump version for ID-based support
        exportedAt: new Date().toISOString(),
        contacts: contacts
    };

    return JSON.stringify(exportData, null, 2);
};

export const restoreJSON = async (jsonContent: string): Promise<number> => {
    try {
        const data = JSON.parse(jsonContent);
        if (!data.contacts || !Array.isArray(data.contacts)) {
            throw new Error("Invalid backup format");
        }

        let count = 0;
        for (const contact of data.contacts) {
            // Validate essential fields
            if (!contact.rawVCard || !contact.timestamp) continue;

            const item: HistoryItem = {
                id: contact.id || crypto.randomUUID(),
                timestamp: contact.timestamp,
                name: contact.name || 'Unknown',
                org: contact.organization,
                vcard: contact.rawVCard,
                images: contact.images, // These are Base64 strings, addHistoryItem will convert to Blobs
                keywords: [] // Will be generated by addHistoryItem
            };

            await addHistoryItem(item);
            count++;
        }
        return count;
    } catch (e) {
        console.error("Restore failed", e);
        throw e;
    }
};

export const downloadJSON = (content: string, filename: string) => {
    const blob = new Blob([content], { type: 'application/json;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.setAttribute('download', filename);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
};
