import { HistoryItem } from '../types';
import { parseVCardString } from './vcardUtils';
import { blobToBase64 } from './imageUtils';
import { addHistoryItem } from './db';

export const generateJSON = async (history: HistoryItem[]): Promise<string> => {
    const contacts = await Promise.all(history.map(async (item) => {
        const parsed = parseVCardString(item.vcard);

        // Convert images to Base64 for export
        let imagesBase64: string[] = [];
        if (item.images && item.images.length > 0) {
            imagesBase64 = await Promise.all(item.images.map(async (img: any) => {
                if (img instanceof Blob) {
                    return await blobToBase64(img);
                }
                if (typeof img === 'string' && img.startsWith('blob:')) {
                    // If it's a blob URL, we can't easily get the blob back synchronously without fetching
                    // But in our app, item.images in memory are ObjectURLs (strings) or Blobs?
                    // In getHistoryPaged, we convert Blob -> ObjectURL.
                    // So here 'img' is likely a blob: URL.
                    try {
                        const res = await fetch(img);
                        const blob = await res.blob();
                        return await blobToBase64(blob);
                    } catch (e) {
                        console.error("Failed to fetch blob for export", e);
                        return null;
                    }
                }
                return img; // Already base64 or unknown
            }));
        }

        return {
            id: item.id,
            name: item.name,
            organization: item.org,
            vcardData: parsed.data,
            rawVCard: item.vcard,
            images: imagesBase64.filter(i => i), // Filter nulls
            source: item.images && item.images.length > 0 ? 'scan' : 'manual',
            timestamp: item.timestamp,
            createdAt: new Date(item.timestamp).toISOString()
        };
    }));

    const exportData = {
        version: "1.0",
        exportedAt: new Date().toISOString(),
        contacts: contacts
    };

    return JSON.stringify(exportData, null, 2);
};

export const restoreJSON = async (jsonContent: string): Promise<number> => {
    try {
        const data = JSON.parse(jsonContent);
        if (!data.contacts || !Array.isArray(data.contacts)) {
            throw new Error("Invalid backup format");
        }

        let count = 0;
        for (const contact of data.contacts) {
            // Validate essential fields
            if (!contact.rawVCard || !contact.timestamp) continue;

            const item: HistoryItem = {
                id: contact.id || crypto.randomUUID(),
                timestamp: contact.timestamp,
                name: contact.name || 'Unknown',
                org: contact.organization,
                vcard: contact.rawVCard,
                images: contact.images, // These are Base64 strings, addHistoryItem will convert to Blobs
                keywords: [] // Will be generated by addHistoryItem
            };

            await addHistoryItem(item);
            count++;
        }
        return count;
    } catch (e) {
        console.error("Restore failed", e);
        throw e;
    }
};

export const downloadJSON = (content: string, filename: string) => {
    const blob = new Blob([content], { type: 'application/json;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.setAttribute('download', filename);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
};
